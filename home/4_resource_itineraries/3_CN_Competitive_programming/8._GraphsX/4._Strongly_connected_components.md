# 4. Strongly connected components
Created Sunday 26 July 2020

- A directed graph is said to be **strongly connected** if there's a path between all pairs of vertices.
- strong connectedness is valid only for directed graphs.

**Strongly connected component(SCC)**
An SCC is a **maximal strongly connected subgraph**.

In other words: A connected subgraph where all pairs of vertices have a path between them, such that no larger(i.e containing more vertices) connected subgraph is possible containing the same vertices.

SCCs can be thought of as **self-contained** **cycles**.

Example of SCCs
![](../../../../assets/4._Strongly_connected_components-image-1-b6b54a78.png)
**Note**

- A single vertex is considered strongly connected.
- Each strongly connected component is actually a DAG.

---

17. How to find SCCs for a give graph?
18. Kosaraju's algorithm - Returns strongly connected components of a directed graph.

### Kosaraju's Algorithm

1. Perform DFS and store completely visited vertexes in a stack (i.e. during the backtrack step after neighbors, for each node).
2. [Transpose](https://en.wikipedia.org/wiki/Transpose_graph) the graph(All in-edges become out-edges and vice-versa).
3. Perform DFS with stack's top node as the start node. When the DFS ends, all visited until now are SCC. Continue the envelop loop, and you'll discover more SCCs. You can use the same visited no problems.

Done!

---

### How does Kosaraju's algorithm work?
1. In our stack, near top will be filled by vertices from a component with an outgoing edge and the ending edges of the trail will be at the bottom. This is for sure going to happen. Property of DFS and our stack selection.
2. In the transpose the outgoing will become in-edges. 
3. Now we start DFS with stack's top node, which is the same as the start node of the previous phase DFS.
4. Now, the SCC that has the start node has no outgoing edge, so DFS here will traversal all in this SCC and stop. When it does, the visited nodes here are an SCC. To store them we can use an integer like 1 (for SCC 1).
5. Due to the envelop loop, we will try some other subgraph and do the same. Ignore the previous SCC's in the envelop (since they will have a lesser group value, like 1).

![](../../../../assets/4._Strongly_connected_components-image-2-b6b54a78.png)
![](../../../../assets/4._Strongly_connected_components-image-3-b6b54a78.png)
![](../../../../assets/4._Strongly_connected_components-image-4-b6b54a78.png)

---

T.C → Same as DFS → O(V+E)

## Code
[Problem](https://www.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1)
```cpp
class Solution
{
	public:
	void dfs(int start, int V, vector<vector<int>>& adj, vector<int>& vis, stack<int> &st) {
	    vis[start] = 1;
	    
	    for(auto nbr: adj[start]) {
	        if (!vis[nbr])
	        {
	            dfs(nbr, V, adj, vis, st);
	        }
	    }
	    
	    st.push(start);
	}
	
	void dfs2(int start, int V, vector<vector<int>>& adj, vector<int>& vis, stack<int> &st, int sccCode) {
	    vis[start] = sccCode;
	    
	    for(auto nbr: adj[start]) {
	        if (!vis[nbr])
	        {
	            dfs2(nbr, V, adj, vis, st, sccCode);
	        }
	    }
	}
	
	//Function to find number of strongly connected components in the graph.
    int kosaraju(int V, vector<vector<int>>& adj)
    {
        vector<int> vis (V, 0);
        stack<int> st;
        for(int i = 0; i < V; i++) {
            if (!vis[i])
            {
                dfs(i, V, adj, vis, st);
            }
        }

		// 1st DFS done
		// Reset visited and transpose the graph
        for(int i = 0; i < V; i++)
            vis[i] = 0;
	    
        vector<vector<int>> adjT (V, vector<int>());
        for(int i = 0; i < V; i++) {
            for(auto nbr: adj[i]) {
                adjT[nbr].push_back(i);
            }
        }
		
        int count = 0;
        while (!st.empty()) {
            int i = st.top();
            st.pop();
            
            if (vis[i]) continue;
            count++;
            dfs2(i, V, adjT, vis, st, count);
        }
        
        return count;
    }
};
```