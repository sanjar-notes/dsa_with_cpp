# 1. DFS
Created Monday 30 March 2020
## Algorithm
DFS is recursive.

We implement the graph as an adjacency matrix:
1. We ask the user number of vertices. We store this as n. Now we assume that the vertices are named from 0 to n-1.
2. We ask for how many edges. The user inputs the edge pairs. We mark (a,b) and (b,a) as true for all inputs 'a' and 'b'.
3. We go through all vertices, calling DFS from it if they are absent from visited, at the same time checking if visited.size()<V. This ensures that **disconnected components are also taken into account.**
   
## Pseudocode
```js
// s = source, aka root
// d = destination
// G = graph (list/matrix/hashmap)

function dfs (s, d, G) {
	vis = [](n); // all nodes, filled with false
	return dfs_helper(s, d, vis, G);
}

function dfs_helper(s, d, vis, G) {
	vis[s] = true; // avoid trail intersection, as we'll handle all emanating
	if (s === d) return true;

	for(let neighbor of G[s]) // there's a loop, so all emanating paths will be considered
	{
		if (!vis[a] && dfs_helper(a, d, vis, G)) return true;
	}
	
	return false;
}
```



*****

**Insights/Takeaways:**

* Having a visited bool array is important. If not used we'll end up in an infinite loop, even if the graph has a single cycle. The way to use it is, when you arrive on a node, immediately mark it as visited, so that any further movement stays away from current trail (since you'll finish all emanating path at some point).
* DFS is "go as deep as possible". But a minor thing to note is once you start coming back, you don't come all the way back, you just go one step back, and continue on second last node, and similarly. i.e. root node's last neighbor is considered in the last path ever.
* Note that we go to the depths until we reach a node where all neighbours have been visited. Hence the name **Depth First Search**.


*****

**Efficiency**
T.C = [O(V+E)](https://stackoverflow.com/a/11468717/11392807)** if we use hashmap as visited array.**
S.C = O(V)

- Time explanation - we will consider all vertices, so its sigma V. we will also consider all edges (assume here that the key is not present and search is going to fail). So we traverse all nodes and try all edges, i.e. (v1 + e1) + (v2 + e2) + ... = (v1 + v2 + ...) + (e1 + e2 + ...) = V + E.
- Space explanation - the max recursion depth can be V, i.e. all nodes are connected along a single trail. and on each node, we have constant space used, so this will be V \* 1 = V. Also, at any given time, only trail exists in the graph, so max size is V. Hence O(V) space.
- In AI class, the graphs are denoted by branching factor (average number of neighbors) and m (max depth). Here time is O(b<sup>m</sup>), to see this, consider the graph is a tree, then calculate E, V and calculate E + V. Space is O(m), to see this, see that max recursion depth is same as max depth, which determined space, so m.

*****

**Tips**
* If graph is dense, use hashmap for G as well as visited.
* Some problems not only need DFS but also has disconnected components. To cover all, add an extra loop for all the vertices. This must be done at the very beginning, and run dfs for vertices that haven't been visited. i.e. usually this loop will reside in the main function (called only once), instead of the helper which is recursive. Applicable to BFS exactly.
  ```js
	function dfs(s, d, G) {
		vis = [](n);

		// you don't know which subgraph the key might be
		// using this, we cover one subgraph at a time, and since they are not connected, they are not affected by each other - i.e. just a for loop is enough, no management required.
		for(let v of vis) {
			if (!vis[v] && dfs_helper(v, d, G)) return true;
		}
		return false;
	}

	function dfs_helper() { /* */ };
	```

[DFS code](./Codes/DFS.cpp)

*****

**Applications**
* Most problems are just variations of DFS and BFS.
* DFS is known not only for searching, but as a way to traverse the graph. To use it for traversal, just never check if key is equal (remove that line), causing the worst case, i.e. all nodes and edges are considered.


