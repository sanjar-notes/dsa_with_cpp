# 5. Prim's Algorithm
Created Saturday 25 April 2020

## Overview
* Generates an MST from a given graph.
* Greedy algorithm: We select the myopically best option.
* The idea is to consider the graph as a tree-part (MST being made) and non-tree-part.
* We iterate over the edges in low to high order, and try to attach them to the tree part.
	* We of course prevent cycles.

## Code

Implementation:
1. Keep a 2-tuple array with i as the vector. (i.e., we store parent and weight). Initially, the parent of start is -1 (no parent), and its weight is zero. All other parents are blank, and weight is INT_MAX (infinity).
2. Keep two lists, **visited** and **unvisited**. Initially, visited is empty and the other is equal to V.
3. Select a minimum weight vertex from the **unvisited** vertices from the **table** and visit its **unvisited** neighbors. If a neighbor has a lesser value, then update the weight and parent (to the current node). Add the current to the visited array. **Remove** it from the unvisited one. Continue until |unvisited| == 0.
4. We have the MST starting from the selected weight.
5. We **need** to find the minimum explicitly, as we may have some 'old' seen minimum which is not our neighbor now. **Our algo explicitly states that we run on the minimum from the table.**

T.C with matrix: O(V<sup>2</sup>)

For an adjacency list with my method: T.C ~ O(Ek) ~ O(E log V)

Optimizations:

1. Using Priority Queue - not required, we did not even have a findMin.
2. Using adjacency list improves the search for neighbors.

T.C: (E+V)log(V) = E log V
